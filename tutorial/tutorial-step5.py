#!/usr/bin/python3

import os
import sys
from random import random, seed
import numpy as np
from time import time
from ase import Atoms
from ase.io import read, write
from ase.data import atomic_numbers
from ase.ga import get_raw_score
from ase.ga.data import DataConnection, PrepareDB
from ase.ga.population import Population
from ase.ga.utilities import (get_all_atom_types, closest_distances_generator,
                              atoms_too_close)
from ase.ga.ofp_comparator import OFPComparator
from ase.ga.startgenerator import StartGenerator
from ase.ga.cutandsplicepairing import CutAndSplicePairing
from ase.ga.standardmutations import RattleMutation
from ase.ga.offspring_creator import OperationSelector
from tango.relax_utils import relax_standard, finalize
from dftbplus_calc import DftbPlusCalculator


def relax_one(atoms):
    """
    This method defines how to locally minimize a given atoms object.
    """
    print('Starting relaxation')
    clock = time()

    # Define the DFTB+ calculator:
    calc = DftbPlusCalculator(atoms, kpts=(1, 1, 1), use_spline=True,
                              maximum_angular_momenta={'Si': 1})

    # Start the actual relaxation using the
    # tango.relax_utils.relax_precon method.
    # This wraps around the ASE optimizers and also
    # takes care of setting the raw score etc.:
    try:
        atoms = relax_standard(atoms, calc, fmax=2e-2, variable_cell=False,
                               logfile=None, trajfile=None, optimizer='BFGS')
    except (IOError, UnboundLocalError):
        # the DFTB+ ASE calculator throws an IOError or
        # UnboundLocalError in case it couldn't find the
        # 'results.tag' output file, which may sporadically
        # happen due to SCC converge issues when e.g. a Si7
        # cluster is breaking into fragments. We simply
        # handle this by aborting the relaxation and
        # assigning a very high energy to the structure:
        finalize(atoms, energy=1e9, forces=None, stress=None)

    print('Relaxing took %.3f seconds.' % (time() - clock), flush=True)
    return atoms


def run_ga(n_to_test):
    """
    This method specifies how to run the GA once the
    initial random structures have been stored in godb.db.
    """
    # Various initializations:
    population_size = 10  # maximal size of the population
    da = DataConnection('godb.db')
    atom_numbers_to_optimize = da.get_atom_numbers_to_optimize()  # = [14] * 7
    n_to_optimize = len(atom_numbers_to_optimize)  # = 7
    # This defines how close the Si atoms are allowed to get
    # in candidate structures generated by the genetic operators:
    blmin = closest_distances_generator(atom_numbers_to_optimize,
                                        ratio_of_covalent_radii=0.4)
    # This is our OFPComparator instance which will be
    # used to judge whether or not two structures are identical:
    comparator = OFPComparator(n_top=None, dE=1.0, cos_dist_max=1e-3,
                               rcut=10., binwidth=0.05, pbc=[False]*3,
                               sigma=0.1, nsigma=4, recalculate=False)

    # Defining a typical combination of genetic operators:
    pairing = CutAndSplicePairing(da.get_slab(), n_to_optimize, blmin)
    rattlemut = RattleMutation(blmin, n_to_optimize, rattle_prop=0.8,
                               rattle_strength=1.5)
    operators = OperationSelector([2., 1.], [pairing, rattlemut])

    # Relax the randomly generated initial candidates:
    while da.get_number_of_unrelaxed_candidates() > 0:
        a = da.get_an_unrelaxed_candidate()
        a = relax_one(a)
        da.add_relaxed_step(a)

    # Create the population
    population = Population(data_connection=da,
                            population_size=population_size,
                            comparator=comparator,
                            logfile='log.txt')
    current_pop = population.get_current_population()

    # Test n_to_test new candidates
    for step in range(n_to_test):
        print('Starting configuration number %d' % step, flush=True)

        a3 = None
        while a3 is None:
            a1, a2 = population.get_two_candidates()
            a3, description = operators.get_new_individual([a1, a2])

        da.add_unrelaxed_candidate(a3, description=description)
        a3 = relax_one(a3)
        da.add_relaxed_step(a3)

        population.update()
        best = population.get_current_population()[0]
        print('Highest raw score at this point: %.3f' % get_raw_score(best))

    print('GA finished after step %d' % step)
    write('all_candidates.traj', da.get_all_relaxed_candidates())
    write('current_population.traj', population.get_current_population())


def prepare_ga(dbfile='godb.db', N=20):
    """
    This method creates a database with the desired number
    of randomly generated structures.
    """ 
    Z = atomic_numbers['Si']
    atom_numbers = [Z] * 7

    # This dictionary will be used to check that the shortest
    # Si-Si distances are above a certain threshold 
    # (here 1.5 Angstrom):
    blmin = {(Z, Z): 1.5}  

    # This defines the cubic simulation cell. In case there
    big_cell = np.identity(3) * 16.
    slab = Atoms('', cell=big_cell)

    # This defines the smaller box in which the initial
    # coordinates are allowed to be generated
    density = 0.1  # in atoms per cubic Angstrom
    L = np.cbrt(len(atom_numbers) / density)
    small_cell = np.identity(3) * L
    p0 = 0.5 * np.diag(big_cell - small_cell)
    box = [p0, small_cell]

    # Seed the random number generators using the system time,
    # to ensure that no two runs produce the same results:
    np.random.seed()
    seed()

    # Generate the random structures and add them to the database:
    sg = StartGenerator(slab=slab, atom_numbers=atom_numbers,
                        closest_allowed_distances=blmin,
                        box_to_place_in=box)

    da = PrepareDB(db_file_name=dbfile,
                   simulation_cell=slab,
                   stoichiometry=atom_numbers)

    for i in range(N):
        a = sg.get_new_candidate()
        da.add_unrelaxed_candidate(a)

    return


if __name__ == '__main__':
    cwd = os.getcwd()
    os.environ['DFTB_PREFIX'] = cwd

    rundir = 'run000'
    if not os.path.exists(rundir):
        os.mkdir(rundir)
    os.chdir(rundir)
 
    dbfile = 'godb.db'
    if not os.path.exists(dbfile):
        prepare_ga(dbfile=dbfile, N=5)

    run_ga(10)

    os.chdir(cwd)