# TANGO search for stable Si<sub>7</sub> clusters

This tutorial tries to demystify the _Tango_ workflow by applying it to the
structure of Si<sub>7</sub> nanoclusters. This system is chosen for its
simplicity and speed, as empirical interatomic potentials for Si
([implemented in CP2K](https://manual.cp2k.org/trunk/CP2K_INPUT/FORCE_EVAL/EIP.html))
will be used to provide the reference energies and forces to which
the DFTB model will be fitted (instead of DFT based methods used
in regular applications). These potentials are able to retreive the true
global minimum structure of Si<sub>7</sub>, which has a pentagonal
bipyramidal, starfish-like geometry (see e.g.
[this work](https://doi.org/10.1063/1.1535906))


## Input files

The run scripts for this tutorial can be found under _tango/examples/si7_.
The folder contains the following:<br>

* _master.py_: used for initializing and controlling the TANGO search.

* _ga.py_: specifies how random structures are generated and how a global
optimization run is to be performed (here using a genetic algorithm (GA)).

* <it>cp2k_calc.py</it>: contains the CP2K calculator class to be used for
calculating the reference energies and forces using [the empirical potential
by  Lenosky and coworkers](https://doi.org/10.1088/0965-0393/8/6/305).
Note: this script assumes that the `cp2k_shell.sopt` (i.e. the serial
CP2K shell binary) is part of your `$PATH`.

* _iter000_: the directory where the first iteration will take place.

* <it>iter000/Si-Si_no_repulsion.skf</it>: contains the 'electronic' DFTB
parameters in
[SKF format](http://www.dftb.org/fileadmin/DFTB/public/misc/slakoformat.pdf)
(with atomic eigenvalues, Hubbard values, occupations in the free atom,
and the Slater-Koster table). This particular file has been generated by
following the first
[Hotcent tutorial](https://gitlab.com/mvdb/hotcent/tutorials/tutorial_1.ipynb).
The 'repulsive' part will be iteratively optimized by _Tango_.


## Step by step

The content of these scripts is explained via documentation inside the scripts.
Here follows a chronology of what is happening when executing the master
script:

1. As a first step, an (<i>initial.db</i>) database is created using the
provided `generator` function, which produces a number of random  structures.
These structures are then partially relaxed using the provided reference
calculator (here, the empirical potential for Si). The energies and forces
of the first and last geometries of each local optimization are added to
the database.

2. Next, the energies of the isolated atoms are calculated using both the
reference method and the DFTB model. The results are saved in
<i>atomic_energies.json</i>.

3. Now a range of dimer binding energies are evaluated using the reference
method and saved in _dimers.db_. This data is then used to fit the
short-range exponential part of the repulsive interactions. The resulting
data points and the fit are shown in <i>Si-Si_exponential.pdf</i>.

4. _Tango_ will now read in the reference energies and forces from 
<i>initial.db</i>, calculate the corresponding properties using DFTB with zero
repulsive interactions, and fit the polynomial coefficients for the repulsive
interactions. The resulting potential is plotted in _Si-Si.pdf_.
The various matrices involved in the linear regression problem are saved
in the NumPy `.npy` format (_A.npy_, _b.npy_, _x.npy_, _w.npy_,
_residuals.npy_), mostly for debugging purposes. The <i>parity_data.txt</i>
file gives a comparison of the DFT and DFTB cohesive energies of each structure
included in the fitting process. The (empty) _PARAMETRIZED_ file is created
to signal that the parametrization has been completed, with creation of the
SKF files which include the repulsive interactions (here: _Si-Si.skf_).

5. Now _Tango_ is ready to randomly generate the first batch of random
structures to be locally optimized with DFTB. In this example, this is done by
performing 2 GA runs in parallel, each with 1 random structure and 0 GA steps
(meaning only the initial population will be relaxed). After both GA runs have
finished, the <i>GO_FINISHED</i> file is touched to mark the completion of
the global optimization (GO) part.

6. _Tango_ now gathers the best unique structures from all the runs using the
same structure comparator as employed by the GA. As only randomly generated
structures have been included in this stage, it is quite unlikely that two runs
will produce the same structure, which means there will usually be 2
structures in the resulting <i>best_unique_iter000.db</i> database.

7. As specified in the <i>master.py</i> script, the code will perform one
more iterations of the same kind, resulting in the creation of the
<i>iter001</i> directory. At each iteration, <i>best_unique_iterXXX.db</i>
database from the previous iteration is copied to the new directory, and
the energy and forces of its structures are evaluated using the reference method
(here: the empirical potential for Si). The repulsive interactions in the DFTB
model are then re-parametrized, taking into account the newly obtained
reference data.

8. After this initial training phase, the actual GO phase is initiated.
Here, this is done by performing two more iterations (in <i>iter002</i>
and <i>iter003</i>) of the same kind, except that each GA run randomly
generates 5 initial structures and carries out a total of 5 GA steps.
The selection of the best unique structures is slightly modified so as
to include only up to 10 candidates.

9. One final step is executed (<i>iter004</i>) where the final selection
(<i>iter003/best_unique_iter003.db</i>) is evaluated using the reference
method, followed by a final reparametrization but no further GO runs.

10. An (empty) <i>iter005</i> directory is created to indicate that future
TANGO steps are to start in this directory.

The <i>iter004/best_unique_iter003.db</i> database therefore contains the
most promising structures obtained with the last reparametrization. For
further analysis, an ASE trajectory with these structures can be extracted
from the database as follows:

```python
from ase.io import read, write
a = read('iter004/best_unique_iter003.db@relaxed=1')
write('final.traj', a)
```

The structures are sorted by their raw score, with the highest scoring
structure in front. Despite the very low number of GA iterations used in this
example, the pentagonal bipyramid structure is usually found among the best
candidates (based on the empirical potential energies at the DFTB geometries).

Subsequent local optimization of the most promising candidates with the
empirical potential suggests that the pentagonal bipyramid is the global
minimum on the empirical potential energy landscape. As an exercise, you may
adapt the files to perform a set of GA runs using the empirical potential
itself, to confirm that the pentagonal bipyramid is indeed the (putative)
global minimum structure.


## Concluding remarks

* In addition to this tutorial, it is recommended to go through the scripts
themselves (<i>ga.py</i>, <i>master.py</i> and <i>cp2k_calc.py</i>) and look
at their documentation.

* At various stages, _Tango_ will try to pick up where it left. First of all,
it looks for the furthest iteration directory, and start from there. If this
happens to be the <i>iter000</i> folder, it will e.g. look for
<i>initial.db</i>, <i>dimers.db</i>, <i>atomic_energies.json</i> and
<i>Si-Si_no_repulsion.skf</i>, and will only generate these files if they are
currently absent. Similarly, if it finds the <i>PARAMETRIZED</i> or
<i>GO_FINISHED</i> files, it will respectively assume the (re)parametrization
or global optimization have been performed and go on with the next task.

* _Tango_ allows for parallelization of the computationally intensive tasks,
i.e. the DFT evaluations and the DFTB GO runs. The conventional way to use
_Tango_ is to engage a fixed number of CPUs (i.e. 20) throughout the entire
process. The DFT calculator should then be set up so as to use 20 MPI processes
(e.g. through the 'command' keyword argument for the ASE interface to CP2K).
The different DFT calculations are then performed in series. The DFTB GO runs
are performed in an embarrasingly parallel fashion using the `multiprocessing`
Python module, where the 20 allocated CPUs are used to run 20 fully independent
DFTB GO runs (each running DFTB+ in serial). For sufficiently large systems
where it makes sense to run DFTB+ in parallel, one could e.g. allocate 40
CPUs and assign two CPUS to each DFTB+ run (through the `$OMP_NUM_THREADS`
variable).

* At a given stage, the DFT calculations are also fully independent, so that
one could e.g. engage many more CPUs for this task. For example, the partial
relaxation of the 20 initial structures with DFT could all be executed in
parallel, each using multiple MPI processes. Although the current _Tango_ code
could in principle be made to work this way (through a similar interaction
with a job scheduler as in
[this ASE tutorial](https://wiki.fysik.dtu.dk/ase/tutorials/ga/ga_optimize.html)),
no example is available at present.

* Although _Tango_ comes with a DFT calculator example (the CP2KCalculator
defined in `tango/calculators/cp2k_calc.py`), you should tailor this
calculator to your needs. One may want to use a different DFT code, or use
CP2K with different settings (basis sets, cutoffs, etc.). The present example
already illustrates the use of a custom calculator (using CP2K, but with
the empirical potential for Si).

* Similarly, one is not restricted to the provided DFTB+ calculator example
specified in `tango/calculators/dftbplus_calc.py`. In certain cases, one
may e.g. wish to turn off the self-consistency loop, or to use a different
diagonalization algorithm (sometimes the Anderson or DIIS algorithms converge
more reliably than the Broyden method).
